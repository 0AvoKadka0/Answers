<h1 align="center">Модели жизненного цикла программного обеспечения</h1>
<h3 align="center">Модели жизненного цикла программного обеспечения (ПО) - это модели, что описывают различные этапы и процессы, через которые проходит разработка, внедрение и поддержка программы от начала до конца ее жизни. Эти модели помогают организовать и структурировать процесс разработки, управлять рисками и оптимизировать использование ресурсов. Включают в себя такие модели, как каскадная модель, модель спирального развития, модель Agile и др. каждая из которых имеет свои особенности и подходы к разработке ПО.</h3>
<hr>
<</h2>
<p>Каскадная модель (Cascade Model) – это одна из классических моделей жизненного цикла разработки программного обеспечения, предлагающая последовательный подход к разработке, основанный на серии фаз, где каждая фаза зависит от завершения предыдущей. В общем, каскадная модель включает следующие этапы:
<ol>
<li>Исследование Концепции</li>
<li>Исследование Системы</li>
<li>Требования</li>
<li>Разработка Проекта</li>
<li>Внедрение</li>
<li>Установка</li>
<li>Эксплуатация и поддержание</li>
<li>Сопровождение</li>
<li>Вывод из эксплуатации</li>
</ol>
</p>
<p>
Каскадная модель может быть использована для создания программного обеспечения, для
которого в самом начале разработки
могут быть точно и в полном объеме заданы все требования. В то же время такой подход имеет
ряд недостатков, вызванных в первую очередь теми, чей реальный
процесс создания программного обеспечения никогда не вписывался в такую схему.</p>
<hr>
<p>V-образная модель основана на идее, что с увеличением времени и перемещением слева направо происходит постепенное углубление в детали проекта. Итерации в проекте выполняются горизонтально, между начальным и заключительным этапами разработки, образуя структуру в виде буквы "V".</p>

<p>V-модель является вариацией каскадной модели, где задачи разработки программного продукта выполняются последовательно сверху вниз по левой стороне буквы "V", в то время как задачи тестирования проводятся вверх по правой стороне буквы "V". Внутри этой модели проводятся горизонтальные линии, отображающие взаимосвязь между результатами каждой стадии разработки и развитием системы тестирования на каждой из стадий тестирования. Модель основана на предположении, что приемо-сдаточные испытания базируются в первую очередь на требованиях, системное тестирование – на требованиях и архитектуре, комплексное тестирование – на требованиях, архитектуре и интерфейсах, а компонентное тестирование – на требованиях, архитектуре, интерфейсах и алгоритмах.
</p>
<hr>
<p>Итерационная модель разработки программного обеспечения представляет собой последовательность итераций, каждая из которых является небольшим циклом разработки, включающим в себя все этапы создания продукта, но в меньшем масштабе по сравнению с проектом в целом. Цель каждой итерации – получить функционирующую версию программного комплекса с определенным набором функций, интегрирующую все предыдущие итерации.

Заключительная итерация включает в себя все необходимые функциональные возможности продукта. Этот метод позволяет разрабатывать продукт поэтапно, повышая шансы на успешное завершение проекта за счет небольших, четко определенных шагов и возможности внесения корректировок на основе обратной связи из реального мира.</p>
<hr>
<p>Инкрементная модель разработки программного обеспечения предполагает создание системы поэтапно. На каждом этапе разработчики используют информацию, полученную на предыдущих этапах, чтобы постепенно улучшать функциональность системы.

Основные этапы разработки включают простую реализацию части требований и последующее усовершенствование в серии последовательных релизов до достижения полной функциональности. Разработка проходит в рамках временного интервала, обычно недельного, с обновлением документации, расширением тестов и добавлением нового кода.

Результатом каждой итерации является работающее, но неполнофункциональное программное обеспечение, которое постепенно совершенствуется. На каждой итерации могут определяться и реализовываться новые требования, а некоторые итерации могут быть посвящены улучшению уже существующего программного продукта.</p>
<hr>
<p>Спиральная модель разработки программного обеспечения основана на создании приложения с помощью нескольких итераций, которые называются витками спирали, с использованием метода прототипирования. Каждая итерация представляет собой создание фрагмента или версии программного обеспечения, определение целей и характеристик проекта, оценку результатов и планирование следующих шагов.

Особое внимание уделяется оценке рисков, таких как нехватка специалистов, нереалистичные сроки и бюджет, а также других факторов, которые могут повлиять на жизненный цикл проекта. Этот подход позволяет более гибко и эффективно управлять процессом разработки, учитывая возможные изменения и препятствия на пути к достижению поставленных целей.</p>
<p>Основная проблема спиральной модели заключается в определении времени перехода на следующую стадию разработки. Для решения этой проблемы вводятся временные рамки для каждой фазы жизненного цикла проекта. Переход на следующую стадию происходит в соответствии с планом, даже если не вся работа завершена. План формируется на основе статических данных из предыдущих проектов и опыта разработчиков. Преимуществами спиральной модели являются ускорение разработки благодаря прототипированию, непрерывное участие заказчика в процессе, декомпозиция работы на более мелкие части и снижение риска.</p>
<hr>

<h1 align="center">Методологии разработки ПО</h1>
<h3 align="center">Методологии управления разработкой ПО являются основой теории управления в этой области. Они классифицируются на прогнозируемые и адаптивные в зависимости от их способности адаптироваться к изменениям. Прогнозируемые методологии ориентированы на детальное планирование проекта с определенными задачами и ресурсами на весь срок выполнения проекта. Они реагируют на изменения требований с трудом, что может привести к существенным изменениям плана и дизайна проекта. Адаптивные методологии направлены на преодоление неполных и постоянно изменяющихся требований. Команды, использующие адаптивные методологии, гибко реагируют на изменения и обладают точным планом только на короткую перспективу, остальные планы существуют в виде деклараций о целях и ожидаемых результатах. Среди адаптивных методологий: Scrum, Crystal, Extreme Programming, Adaptive Software Development, DSDM, Feature Driven Development, Lean software development.</h3>
<hr>
<p>Один из самых известных процессов, использующих итеративную
модель разработки – RUP.Термином RUP обозначает как
методологию, так и продукт компании IBM (ранее Rational) для
управления процессом разработки. Методология RUP описывает
абстрактный общий процесс, на основе которого организация или
проектная команда должна создать специализированный процесс,
ориентированный на ее потребности. </p>
<hr>
<h5>Архитектура</h5>
<p>RUP (Rational Unified Process) – методология, ориентированная на архитектуру системы. Стремится к тому, чтобы реализация и тестирование архитектуры начинались на ранних стадиях проекта. Вводит концепцию исполняемой архитектуры – основы приложения, позволяющие реализовать ключевые архитектурные решения. Эти основы должны быть созданы как можно раньше, что позволяет оценить и корректировать архитектурные решения на ранней стадии проекта. Для начальных итераций выбираются прецеденты, требующие реализации основных архитектурных компонентов. RUP поощряет использование визуальных средств, таких как UML (Unified Modeling Language), включая Rational Rose, для анализа и проектирования. Модель предметной области документируется при помощи диаграмм классов, модель прецедентов использования – диаграммой прецедентов, а взаимодействие компонентов системы – диаграммой последовательности.</p>
<h5>Жизненный цикл проекта</h5>
<p>Начало (Inception)
Стадия «начало» обычно состоит из одной итерации. В ходе
выполнения этой стадии необходимо:
<li>- определить видение и границы проекта;</li>
<li>- создать экономическое обоснование;</li>
<li>- идентифицировать большую часть прецедентов использования и
подробно описать несколько ключевых прецедентов;</li>
<li>- найти хотя бы одно возможное архитектурное решение;</li>
<li>- оценить бюджет, график и риски проекта.</li>
Если после завершения первой итерации заинтересованные лица
приходят к выводу о целесообразности выполнения проекта, проект
переходит в следующую стадию. В противном случае проект может быть
отменен или проведена еще одна итерация стадия «начало».
Проектирование (Elaboration)
В результате выполнения этой стадии на основе требований и
рисков проекта создается основа архитектуры системы. Проектирование
может занимать до двух-трех итераций или быть полностью
пропущенным (если в проекте используется архитектура существующей
системы без изменений). Целями этой фазы являются:
<li>- детальное описание большей части прецедентов использования;</li>
<li>- создание оттестированной (при помощи архитектурно значимых
прецедентов использования) базовой архитектуры;</li>
<li>- снижение основных рисков и уточнение бюджета и графика
проекта.</li>
В отличие от каскадной модели, основным результатом этой стадии
является не множество документов со спецификациями, а действующая
система с 20-30% реализованных прецедентов использования [25].
Построение (Construction)
В этой стадии (длящейся от двух до четырех итераций) происходит
разработка окончательного продукта. Вовремя ее выполнения создается
основная часть исходного кода системы и выпускаются промежуточные
демонстрационные прототипы.</p>
<hr>
<p>Scrum предоставляет эмпирический подход к разработке ПО. Этот
процесс быстр, адаптивен, умеет подстраиваться и отличен от каскадной
модели. Scrum основан на повторяющихся циклах, это делает его более
гибким и предсказуемым.</p>
<hr>
<p>При использовании eXtreme Programming (XP) основное внимание уделяется постоянному взаимодействию с заказчиком и регулярному улучшению кода через рефакторинг. Вместо тщательного предварительного проектирования, в команде есть заказчик, готовый оценить прототипы и отвечать на вопросы. Основой документации считается хорошо прокомментированный код. Особое внимание уделяется тестированию, где сначала пишется тест для каждого нового метода, а затем разрабатывается код метода до тех пор, пока тест не проходит успешно. Эти тесты автоматически выполняются после любого изменения кода. Парное программирование и 40-часовая рабочая неделя способствуют высокой производительности и сокращению ошибок при разработке.</p>
<hr>
<p>Crystal Clear - это легковесная гибкая методология, разработанная Алистером Коуберном для небольших команд размером 6-8 человек, работающих над некритичными бизнес-приложениями. Основной акцент делается на людей, а не на процессы и артефакты. Она также поддерживает итеративную инкрементную разработку, автоматическое регрессионное тестирование, активное участие пользователей в проекте, определение состава документации участниками проекта и использование средств контроля версий кода. Crystal Clear, хоть и уступает по производительности XP, но при этом проста в использовании и требует минимальных усилий для внедрения. Она описывает естественный порядок разработки ПО, который устанавливается в квалифицированных коллективах без целенаправленного внедрения других методологий.Crystal Clear использует семь методов/практик, три из
которых являются обязательными:
<li>- частая поставка продукта;</li>
<li>- улучшения через рефлексию;</li>
<li>- личные коммуникации;</li>
<li>- чувство безопасности;</li>
<li>- фокусировка;</li>
<li>- простой доступ к экспертам;</li>
<li>- качественное техническое окружение.</li>
</p>

<h1 align="center">Классификация информационных систем</h1>
<p>ИС можно классифицировать по следующим критериям:
<ol>
  <li>По сложности создания и сопровождения.</li>
 <li>По концептуальной модели использования (целевое назначение сис-
темы).</li>
<li>По характеру представления и логической организации хранимой
информации (как организована база данных).</li>
<li> По способу реализации БД (как реализована база данных).</li></ol>
<h5>Сложность создания и сопровождения.</h5> Специфика решаемых ИС задач,
сложность их создания, сопровождения и время жизни ИС позволяют разде-
лить их на три класса.
<ol>
<li> Малые.</li>
<li>Средние.</li>
<li> Крупные – корпоративные ИС (КИС).</li></ol></p>
<h1 align="center">Методы структурного анализа</h1>
<p>Фаза анализа – основополагающая. Ошибки этой фазы имеют самые
тяжелые последствия.</p>
<h5>Модель предметной области</h5> <p>– это представление понятий, выражен-
ных в терминах предметной области задачи.
Анализ это очень широкое понятие, которое в свою очередь можно по-
делить на две разновидности:
  <ol>
<li>) структурный системный анализ;</li>
<li>) объектно-ориентированный анализ.</li>
  </ol></p>
  <hr>
  <p>В основе методов структурного анализа лежат следующие основные3
принципа:
<ol>
<li>. Разбиение системы на черные ящики (принцип «разделяй и властвуй»).
Разбиение должно удовлетворять следующим критериям:</li>
<ul>
<li>- каждый черный ящик должен реализовывать одну единственную функ-
цию системы;</li>
<li>- функция каждого черного ящика должна быть легко понимаема незави-
симо от его сложности;</li>
<li>- связь между черными ящиками должна вводиться только при наличии
связи между существующими реально функциями системы;</li>
<li>- связи между черными ящиками должны быть по возможности простыми,
для обеспечения независимости между ними.</li></ul>
<li>. Идея иерархии (принцип иерархического упорядочивания).
Помимо разбиения системы на части их необходимо определенным об-
разом упорядочить. В виде иерархических структур.</li>
<li>. Структурные методы широко используют графические нотации, слу-
жащие для облегчения понимания сложных систем.</li>
Нотация - это средство описания структуры системы, данных и этапов
обработки в виде диаграмм, графов, блок-схем, таблиц, языков.
Помимо двух основных принципов в структурном анализе используется
еще и ряд второстепенных, но не менее важных. К ним относятся:</ol>
<ol><li>) принцип абстрагирования – выделение существенных с некоторых по-
зиций аспектов системы и отвлечение от несущественных для простоты
представления системы;</li>
<li>) принцип формализации – необходимость строго методического подхо-
да к решению проблемы;</li>
<li>) принцип упрятывания – упрятывание несущественной на конкретном
этапе информации;</li>
<li>) принцип полноты – контроль на присутствие лишних элементов;</li>
<li>) принцип непротиворечивости – обоснованность и согласованность
элементов;</li>
<li>) принцип логической независимости – сосредоточение внимания на ло-
гическом проектировании без привязки его к физическому;</li>
<li>) принцип независимости данных – модели данных должны анализиро-
ваться и проектироваться без привязки к их логической обработке и
физическому распределению;</li>
<li>) принцип структурирования данных – структуризация данных.
На основе перечисленных принципов создано три метода, позволяющих
построить:</li></ol>
    <ul>
<li> функциональную структуру (функции, которые система должна выпол-
нять);</li>
<li> информационную структуру (отношения между данными);</li>
 <li> алгоритм функционирования системы (зависящее от времени поведение
системы).</li></ul>
Методы используют нотации. Методы (или техники построения струк-
турной диаграммы функций, данных или событий) используют следующие
средства моделирования системы (нотации):
    <ul>
<li>- IDEF0 функциональные диаграммы;</li>
<li>- DFD (Data Flow Diagrams) диаграммы потоков данных совместно со сло-
варями данных и спецификациями процессов или миниспецификациями;</li>
<li>- ERD (Entity-Relationship Diagrams) диаграммы «сущность-связь»;</li>
<li>- STD (State Transition Diagrams) - диаграммы перехода состояний.</li></ul>
Модели, построенные с использованием перечисленных диаграмм в их
различной комбинации, в совокупности дают полное описание ИС независи-
мо от того, является ли она существующей или вновь разрабатываемой. Со-
став диаграмм в каждом конкретном случае зависит от необходимой полноты
описания системы.
Перечисленные методы в различной комбинации используются методо-
логиями. </p>
<hr>
<h1 align="center">Функциональные модели</h1>
<p>Методология SADT – это совокупность методов, правил и процедур,
предназначенных для функционального моделирования предметной области.
Активностная модель – это совокупность диаграмм, текста и глосса-
рия. Диаграммы – главные компоненты модели. В моделях используется гра-
фический язык. Разработчик диаграмм – аналитик. Диаграммы могут детали-
зироваться введением новых уровней, организуются в иерархические древо-
видные структуры. Каждая диаграмма нижнего уровня детализирует«внут-
реннее состояние» блока на родительской диаграмме.</p>
<hr>
<p>Это основное средство моделирования функциональных требований к системе. внешние
сущности порождают информационные потоки переносящие информацию к подсистема. Подсистемы
преобразуют информацию и порождают новые потоки, которые переносят
информацию к другим подсистемам, накопителям данных или
внешним сущностям.
Внешняя сущность – это материальный предмет или физическое лицо,
представляющее собой источник или приемник информации.
Процесс - преобразование входных потоков данных в выходные в соответствии с действием, задаваемым именем процесса.
Накопитель данных - абстрактное устройство для хранения информации.
Поток данных определяет информацию, передаваемую через некоторое
соединение от источника к приемнику.</p>
<p>Главная цель построения модели– создание ясных и понятных требо-
ваний к системе на каждом уровне детализации. Декомпозиция DFD осуществляется на основе процессов, каждый процесс раскрывается на основе DFD
нижнего уровня.
Контекстная диаграмма КД- моделирует систему наиболее общим
видом, отражает интерфейс системы с внешними сущностями.
Миниспецификация (спецификация процесса) - описание логики процесса, конечная ветка иерархии DFD, по которой можно разработать соответствующую программу или реализацию.
Словарь данных – это определенным образом организованный список
всех элементов данных системы с их точными определениями.</p>
<hr>
<h1 align="center">Структурное проектирование</h1>
<p>На этапе структурного анализа строится модель требований, состоящая
из множества взаимоувязанных диаграмм, текстов и словаря данных.Для осуществления детализации реализации исполь-
зуется фаза «Проектирование» ЖЦ, на которой определяется, как реализуют-
ся требования, зафиксированные на фазе анализа.
Структурные карты - инструмент для демонстрации структуры сис-
темы и составляющих ее программных модулей, а также их связей друг с
другом.
Модули – это базовые строительные блоки программной системы</p>
<hr>
<h1 align="center">Связность</h1>
<p>cвязность – это мера функциональной зависимости объектов внутри
одного модуля.
Функционально связный модуль-содержит объекты, предназначенные
для выполнения только одной задачи.
Информационно связный модуль-содержит объекты, использующие од-
ни и те же входные или выходные данные.
Процедурно связный модуль-является модулем, объекты которого вклю-
чены в различные подзадачи, в которых управление
переходит от каждой подзадачи к последующей.
Временно связным-является модуль, объекты которого включены в под-
задачи, связанные временем исполнения.
Модулем с логической связностью-является модуль, объекты которого
содействуют решению одной общей подзадачи.
Случайно связным-является модуль, объекты которого соответствуют
подзадачам, незначительно связанным друг с другом.</p>
<hr>
<h1 align="center">Понятие бизнес-процесса</h1>
<p>Бизнес-процесс – это набор операций, которые, вместе взятые, образуют
результат, имеющий ценность для потребителя. При этом бизнес-процесс
представляет собой некоторую деятельность, получающую входные данные
одного или нескольких типов и выдающую результат, имеющий ценность для
клиента.</p>
<hr>
<h1 align="center">CASE-технологии</h1>
<p>CASE-средство - любое программное средство, автоматизирующее ту
или иную совокупность процессов жизненного цикла программного обеспечения.
Реинженеринг – это перепроектирование существующей системы. На
основе имеющейся системы получается модель, которая дорабатывается и
реорганизуется в новую систему.
Репозитарий - место для хранения моделей, интерфейсов и программных реализаций; часть окружения для манипулирования
артефактами проектирования.
Артефакт – это элемент информации, используемый или порождаемый в процессе разработки программного обеспечения</p>
<hr>
<p>Объектно-ориентированное программирование — это методология программирования, основанная на представлении программы как набора объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.
ООП – это альтернатива алгоритмической декомпозиции, которая не
делит задачу на последовательность шагов– как ее решить, а представляет
задачу в виде взаимодействия объектов, принимающих в ней участие и взятых из словаря предметной области.
Объектно-ориентированный метод разработки ПО произошел на основе
развития всех предыдущих методов и вылился в создании объектноориентированных языков программирования, которые представляют собой не
более чем инструмент для написания объектно-ориентированных программ.
Достоинства ООП перед алгоритмическим:
  <ol>
<li>) уменьшается размер программных систем за счет использования готовых кодов;</li>
<li>) в результате получаются более гибкие системы и более эволюционирующие;</li>
<li>) уменьшается риск создания системы, потому что строится из проверенных кирпичиков.</li></ol>
Объект – это сущность, имеющая некоторое состояние (информацию) и
предоставляющая набор операций, с помощью которых можно изменять или
проверять это состояние.
Инкапсуляция – это обеспечиваемое объектами сокрытие информации.
Те операции, которые может выполнять объект, – это его интерфейс.
Интерфейс – описание того, как объект взаимодействует с окружающим миром.
Метод – это предоставляемый сервис а совокупность методов представляет собой интерфейс объекта.</p>
<hr>
<p>Класс – это шаблон создания объектов.
Все объекты одного и того же класса обладают одинаковым интерфейсом и реализуют его одинаково.
Экземпляр – это объект, принадлежащий некоторому классу.
Классы считаются одинаковыми, если у них совпадают все атрибуты,
все интерфейсы и реализация этих интерфейсов.
Наследование – это отношение между классами, при котором один
класс разделяет структуру или поведение одного или нескольких других.
Иерархия классов – это описание отношений наследования между классами.
Полиморфизм – механизм, позволяющий скрывать различные реализации за общим интерфейсом.
Ассоциация – двухсторонняя связь между объектами разных классов.
Наследование- это когда один объект наследует все или часть атрибутов и методов другого или других объектов.
Использование – вызов методов другого класса. Часто встречается в
программах.
Агрегация – это когда один класс включает другой в качестве атрибут.
Метаданные – это данные о данных, которые
описывают структуру классов и объектов. </p>
<hr>
<p>Объектно-ориентированный анализ и проектирование ООА/П – это поуровневый спуск от концептуальной модели использования системы к логической, а затем к физической реализации.
Прецедент – это механизм упрощения формулировки требований всех
заинтересованных лиц, это рассказы об использовании системы в процессе
решения поставленных задач.
Исполнитель – это некоторая сущность, обладающая поведением и являющаяся инициатором какого-либо действия в системе.
Сценарий – это специальная последовательность действий или взаимодействий между исполнителями и системой.
UML – это язык для определения, визуализации, конструирования и документирования артефактов программных систем.</p>
